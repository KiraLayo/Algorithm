# 动态规划

是一种算法思想，而非固定算法，应用这种算法思想解决问题的可行性，对 **子问题与原问题的关系** ，以及 **子问题之间的关系这** 两方面有一些要求，它们分别对应了 **最优子结构** 和 **重复子问题** .

## 最优子结构

动态规划要解决的都是一些问题的 **最优解**，即从很多解决问题的方案中找到最优的一个，一个问题的**最优解是由它的各个子问题的最优解决定的**。

将**子问题的解**进行**组合**可以**得到原问题的解**是动态规划可行性的关键。

问题的解为 f(n)，f(n) 也叫**状态**，状态转移方程，描述了一种原问题与子问题的组合关系，原问题上有一些选择，不同选择可能对应不同的子问题或者不同的组合方式。

$$
f(n)=\begin{cases}
a_1x+b_1y+c_1z=d_1 & n=2k+1\\
a_2x+b_2y+c_2z=d_2 & n=2k\\
\end{cases}
$$

$$
原问题
\begin{cases}
子问题1\\
子问题2\\
\cdots\\
\end{cases}
->
\left.
\begin{cases}
子问题1最优解\\
子问题2最优解\\
\cdots\\
\end{cases}
\right\}
->
组合
->
最优解
$$

## 重复子问题

当我们在递归地寻找每个子问题的最优解的时候，有可能会会重复地遇到一些更小的子问题，会产生重复计算，动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。

重复子问题**不是**保证解的正确性**必须的**，但是 **如果** 递归求解子问题时，**没有**出现重复子问题，则没有必要用动态规划，**直接** 普通的 **递归** 就可以了。

使用 **记忆化递归法**：若能事先确定子问题的范围就可以建表存储子问题的答案。解决重复子重复计算问题。

## 关键点

* 证明问题的方案中包含一种选择，选择之后留下一个或多个子问题
* 设计子问题的递归描述方式
* 证明对原问题的最优解包括了对所有子问题的最优解
* 证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）

## 动态规划解决问题的过程

找出子问题及其子问题与原问题的关系

1. 定义状态 **f(n)**
2. 推导状态转移方程，如何通过 **f(1), f(2) … f(n - 1)** 推导出 **f(n)**，
3. 初始化和边界条件

## 与分治区别

解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。

存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上组合出来的，但是不存在重复子问题，因为不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠。

## 与贪心区别

* 最优子结构
  * 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
  * 动态规划：最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解
* 组合方式
  * 贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
  * 动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案
* 正确性
  * 贪心 **不能保证** 求得的最后 **解是最佳** 的，**复杂度低**
  * 动态规划 **本质** 是 **穷举法**，**可以保证** 结果 **是最佳** 的，**复杂度高**。

| | 分治 | 动态规划 | 贪心 |
| - | - | - | - |
| **适用类型** | 通用 | 优化 | 优化 |
| **子问题** | 每个都不同 | 有很多重复 | 只有一个 |
| **最优子结构** | 没有要求 | 必须满足 | 必须满足 |
| **子问题数** | 全部都要解 | 全部都要解 | 只解一个 |

## 动态规划问题类别

### 线性动态规划

状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。

可以用于解决 **单串，双串，矩阵** 的问题，因为问题的规模可以完全用位置表示。

### 区间动态规划

区间 DP 是状态的定义和转移都与区间有关，其中区间用两个端点表示。

状态定义 **dp[i][j] = [i..j]** 上原问题的解。i 变大，j 变小都可以得到更小规模的子问题。

区间动态规划的状态设计，状态转移都与线性动态规划有明显区别，这两种方法都经常用在单串问题。

状态转移，推导状态 dp[i][j] 时，有两种常见情况：

* dp[i][j] 仅与常数个更小规模子问题有关
    * 一般是与 dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1] 有关。
* dp[i][j] 与 O(n) 个更小规模子问题有关
    * 一般是枚举 [i,j] 的分割点，将区间分为 [i,k] 和 [k+1,j]，对每个 k 分别求解（下面公式的 f），再汇总（下面公式的 g）。
    
### 前缀

针对这个不变的数组，前缀和用于多次查询区间 [i, j] 上元素的结果。

#### 前缀和

对于动态规划而言，前缀和的意义主要有两点：

一维和二维前缀和的推导，分别用到了单串和矩阵中最经典的状态设计以及状态转移；
在一些更复杂的动态规划问题中，状态转移的时候需要依赖区间和，因为状态转移是非常频繁的操作，因此必须高效地求区间和才能使得状态转移的时间复杂度可接受，此时就必须用到前缀和了。

除此之外，一些问题需要前缀和与其它数据结构配合来解决，也有两类：

* 先预处理出前缀和数组，这一步是动态规划，然后在前缀和数组上用其它数据结构解决；
* 还是按照动态规划的方式求前缀和，也需要额外的数据结构维护前缀和，但不是预处理好前缀和数组之后再用数据结构计算，而是每求出一个前缀和，就更新一次数据结构并维护答案。

#### 运算推广

如果利用前缀上的某种运算的结果，可以像前缀和一样快速得到区间 [L, R] 上同样运算的结果，那么前缀和就成功推广了。

如果想将某种运算应用到前缀元素上，并且利用前缀的结果快速计算区间结果，需要该运算满足 ** 区间减法 **：区间 A = [i, j]，区间 B = [i, k] 区间 C = [k+1, j]，那么有了大区间 A 上的结果 a 和其中一个小区间 B 上的结果 b, 要能够算出另一个小区间 C 上的结果 c 。

一般推广有：

* 异或：a=b⊕c=>c=b⊕a
* 乘法/模下乘法：a=b×c=>c=a/b

### 差分

* **前缀和** 的差分序列等于原序列。
* 原序列的差分序列求前缀和序列得到原序列。
* 再区间
* 差分序列的好处是如果要对原序列的一个区间 **[l, r] **上所有值加 val,原序列上要操作** r−l+1** 次,在差分序列上只需要操作 2 次(b[l] + val, b[r+1] - val)。如果这种区间操作需要很多次，最后的查询只有一次的话，就非常适合在差分序列上操作。


