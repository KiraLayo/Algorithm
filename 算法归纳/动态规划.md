# 动态规划

是一种算法思想，而非固定算法，应用这种算法思想解决问题的可行性，对 **子问题与原问题的关系** ，以及 **子问题之间的关系这** 两方面有一些要求，它们分别对应了 **最优子结构** 和 **重复子问题** .

## 最优子结构

动态规划要解决的都是一些问题的 **最优解**，即从很多解决问题的方案中找到最优的一个，一个问题的**最优解是由它的各个子问题的最优解决定的**。

将**子问题的解**进行**组合**可以**得到原问题的解**是动态规划可行性的关键。

问题的解为 f(n)，f(n) 也叫**状态**，状态转移方程，描述了一种原问题与子问题的组合关系，原问题上有一些选择，不同选择可能对应不同的子问题或者不同的组合方式。

$$
f(n)=\begin{cases}
a_1x+b_1y+c_1z=d_1 & n=2k+1\\
a_2x+b_2y+c_2z=d_2 & n=2k\\
\end{cases}
$$

$$
原问题
\begin{cases}
子问题1\\
子问题2\\
\cdots\\
\end{cases}
->
\left.
\begin{cases}
子问题1最优解\\
子问题2最优解\\
\cdots\\
\end{cases}
\right\}
->
组合
->
最优解
$$

## 重复子问题

当我们在递归地寻找每个子问题的最优解的时候，有可能会会重复地遇到一些更小的子问题，会产生重复计算，动态规划可以保证每个重叠的子问题只会被求解一次。当重复的问题很多的时候，动态规划可以减少很多重复的计算。

重复子问题**不是**保证解的正确性**必须的**，但是 **如果** 递归求解子问题时，**没有**出现重复子问题，则没有必要用动态规划，**直接** 普通的 **递归** 就可以了。

使用 **记忆化递归法**：若能事先确定子问题的范围就可以建表存储子问题的答案。解决重复子重复计算问题。

## 关键点

* 证明问题的方案中包含一种选择，选择之后留下一个或多个子问题
* 设计子问题的递归描述方式
* 证明对原问题的最优解包括了对所有子问题的最优解
* 证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）

## 动态规划解决问题的过程

找出子问题及其子问题与原问题的关系

1. 定义状态 **f(n)**
2. 推导状态转移方程，如何通过 **f(1), f(2) … f(n - 1)** 推导出 **f(n)**，
3. 初始化和边界条件

## 与分治区别

解决分治问题的时候，思路就是想办法把问题的规模减小，有时候减小一个，有时候减小一半，然后将每个小问题的解以及当前的情况组合起来得出最终的结果。

存在有最优的子结构，即原数组的排序结果是在子数组排序的结果上组合出来的，但是不存在重复子问题，因为不断地对待排序的数组进行对半分的时候，两半边的数据并不重叠。

## 与贪心区别

* 最优子结构
  * 贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录
  * 动态规划：最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解
* 组合方式
  * 贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
  * 动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案
* 正确性
  * 贪心 **不能保证** 求得的最后 **解是最佳** 的，**复杂度低**
  * 动态规划 **本质** 是 **穷举法**，**可以保证** 结果 **是最佳** 的，**复杂度高**。

| | 分治 | 动态规划 | 贪心 |
| - | - | - | - |
| **适用类型** | 通用 | 优化 | 优化 |
| **子问题** | 每个都不同 | 有很多重复 | 只有一个 |
| **最优子结构** | 没有要求 | 必须满足 | 必须满足 |
| **子问题数** | 全部都要解 | 全部都要解 | 只解一个 |

## 动态规划类别

### 线性动态规划

状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。

可以用于解决 **单串，双串，矩阵** 的问题，因为问题的规模可以完全用位置表示。

#### 单串

状态定义：dp[i] := 考虑[0..i]上，原问题的解

其中 **i** 位置的处理如下：

* **i** 位置必须取
* **i** 位置可取可不取

状态方程推导公式种类如下：

* 依赖比 i 小的 O(1) 个子问题
  * dp[n] 只与常数个小规模子问题有关
* 依赖比 i 小的 O(n) 个子问题
  * dp[n] 与此前的更小规模的所有子问题 dp[n - 1], dp[n - 2], ..., dp[1] 都可能有关系。

